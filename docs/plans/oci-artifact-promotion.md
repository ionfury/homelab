# OCI Artifact-Based Environment Promotion

## Overview

Replace git-branch-based promotion with **OCI artifact promotion** where the entire `kubernetes/` directory becomes an immutable, validated artifact that flows through environments.

**Supersedes:** `docs/plans/renovate-flux-promotion.md` (version-file promotion approach)

---

## Problem Statement

The previous approach (version-file promotion) only protected against **version changes** breaking production. It did NOT protect against:
- Configuration changes breaking services
- Manifest modifications causing failures
- Helm values changes causing issues

**Solution:** Package the entire `kubernetes/` directory as an OCI artifact. Promote the **whole artifact** after validation, not just version numbers.

---

## Architecture

### Promotion Flow

```
PR merged to main
       │
       ▼
┌─────────────────────────────┐
│  GHA: Build OCI Artifact    │
│  Tag: sha-<commit>          │
│  Tag: integration-<commit>  │
└─────────────────────────────┘
       │
       ▼
┌─────────────────────────────┐
│  GHCR Registry              │
│  platform:sha-abc123        │
│  platform:integration-*     │
│  platform:validated-*       │
└─────────────────────────────┘
       │
       ├──────────────────────────────────────┐
       │                                      │
       ▼                                      │
┌─────────────────┐                           │
│  Integration    │                           │
│  OCIRepository  │                           │
│  tag: integration-*                         │
│  (auto-deploy)  │                           │
└─────────────────┘                           │
       │                                      │
       ▼                                      │
┌─────────────────────────────┐               │
│  Flagger Validation         │               │
│  - Flux reconciliation      │               │
│  - Smoke tests              │               │
└─────────────────────────────┘               │
       │                                      │
       │ validation passes                    │
       ▼                                      │
┌─────────────────────────────┐               │
│  GHA: Tag as validated-*    │               │
└─────────────────────────────┘               │
       │                                      │
       ▼                                      │
┌─────────────────┐                           │
│  Live           │◄──────────────────────────┘
│  OCIRepository  │
│  tag: validated-*
│  (ImagePolicy)  │
└─────────────────┘
```

### Cluster Source Strategy

| Cluster | Source Type | Tag Pattern | Update Mechanism |
|---------|-------------|-------------|------------------|
| dev | GitRepository | N/A (branch: main) | Direct git push |
| integration | OCIRepository | `integration-*` | ImagePolicy + ImageAutomation |
| live | OCIRepository | `validated-*` | ImagePolicy + ImageAutomation |

### Tag Lifecycle

```
1. Build creates:     sha-abc123, integration-abc123
2. Integration deploys integration-abc123 (ImagePolicy picks latest integration-*)
3. Flagger validates
4. On success:        validated-abc123 (GHA adds this tag)
5. Live deploys validated-abc123 (ImagePolicy picks latest validated-*)
```

---

## Implementation Plan

### Phase 1: Prerequisites

#### 1.1 Create Integration/Live Cluster Directories

The bootstrap module already generates these files via Terragrunt. Verify they exist after running `task tg:apply-integration` and `task tg:apply-live`:

```
kubernetes/clusters/
├── dev/                    # EXISTS
│   ├── kustomization.yaml
│   ├── platform.yaml
│   ├── .cluster-vars.env
│   └── .versions.env
├── integration/            # GENERATED by Terragrunt
│   ├── kustomization.yaml
│   ├── platform.yaml
│   ├── .cluster-vars.env
│   └── .versions.env
└── live/                   # GENERATED by Terragrunt
    ├── kustomization.yaml
    ├── platform.yaml
    ├── .cluster-vars.env
    └── .versions.env
```

#### 1.2 Create GHCR Repository

The OCI artifact will be stored at: `ghcr.io/<org>/homelab/platform`

GHCR creates repositories automatically on first push. Ensure GitHub Actions has `packages: write` permission.

---

### Phase 2: Build Pipeline

#### 2.1 Create Build Workflow

**File:** `.github/workflows/build-platform-artifact.yaml`

```yaml
name: Build Platform Artifact

on:
  push:
    branches: [main]
    paths:
      - 'kubernetes/**'
  workflow_dispatch:
    inputs:
      tag_suffix:
        description: 'Optional tag suffix (defaults to commit SHA)'
        type: string

env:
  REGISTRY: ghcr.io
  ARTIFACT_REPO: ${{ github.repository }}/platform

jobs:
  build:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    outputs:
      sha: ${{ github.sha }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Flux CLI
        uses: fluxcd/flux2/action@main

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Determine tags
        id: tags
        run: |
          SHA="${{ github.sha }}"
          SHORT_SHA="${SHA:0:7}"

          if [ -n "${{ inputs.tag_suffix }}" ]; then
            SUFFIX="${{ inputs.tag_suffix }}"
          else
            SUFFIX="${SHORT_SHA}"
          fi

          echo "sha_tag=sha-${SHORT_SHA}" >> $GITHUB_OUTPUT
          echo "integration_tag=integration-${SHORT_SHA}" >> $GITHUB_OUTPUT
          echo "short_sha=${SHORT_SHA}" >> $GITHUB_OUTPUT

      - name: Push OCI artifact
        run: |
          flux push artifact \
            oci://${{ env.REGISTRY }}/${{ env.ARTIFACT_REPO }}:${{ steps.tags.outputs.sha_tag }} \
            --path=./kubernetes \
            --source="https://github.com/${{ github.repository }}" \
            --revision="${{ github.ref_name }}@sha1:${{ github.sha }}"

      - name: Tag for integration
        run: |
          flux tag artifact \
            oci://${{ env.REGISTRY }}/${{ env.ARTIFACT_REPO }}:${{ steps.tags.outputs.sha_tag }} \
            --tag ${{ steps.tags.outputs.integration_tag }}

      - name: Summary
        run: |
          echo "## Platform Artifact Built" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Registry:** \`${{ env.REGISTRY }}/${{ env.ARTIFACT_REPO }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Tags:**" >> $GITHUB_STEP_SUMMARY
          echo "- \`${{ steps.tags.outputs.sha_tag }}\` (immutable)" >> $GITHUB_STEP_SUMMARY
          echo "- \`${{ steps.tags.outputs.integration_tag }}\` (integration auto-deploy)" >> $GITHUB_STEP_SUMMARY
```

#### 2.2 Create Validation Tag Workflow

**File:** `.github/workflows/tag-validated-artifact.yaml`

```yaml
name: Tag Validated Artifact

on:
  repository_dispatch:
    types: [artifact-validated]
  workflow_dispatch:
    inputs:
      artifact_sha:
        description: 'Short SHA of artifact to tag as validated (e.g., abc1234)'
        required: true
        type: string

env:
  REGISTRY: ghcr.io
  ARTIFACT_REPO: ${{ github.repository }}/platform

jobs:
  tag:
    runs-on: ubuntu-latest
    permissions:
      packages: write

    steps:
      - name: Setup Flux CLI
        uses: fluxcd/flux2/action@main

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Determine SHA
        id: sha
        run: |
          if [ -n "${{ inputs.artifact_sha }}" ]; then
            SHA="${{ inputs.artifact_sha }}"
          else
            SHA="${{ github.event.client_payload.artifact_sha }}"
          fi

          if [ -z "${SHA}" ]; then
            echo "Error: No artifact SHA provided"
            exit 1
          fi

          echo "sha=${SHA}" >> $GITHUB_OUTPUT

      - name: Tag as validated
        run: |
          SOURCE_TAG="integration-${{ steps.sha.outputs.sha }}"
          VALIDATED_TAG="validated-${{ steps.sha.outputs.sha }}"

          echo "Tagging ${SOURCE_TAG} as ${VALIDATED_TAG}"

          flux tag artifact \
            oci://${{ env.REGISTRY }}/${{ env.ARTIFACT_REPO }}:${SOURCE_TAG} \
            --tag ${VALIDATED_TAG}

      - name: Summary
        run: |
          echo "## Artifact Validated" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Artifact:** \`${{ steps.sha.outputs.sha }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**New tag:** \`validated-${{ steps.sha.outputs.sha }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Live cluster will auto-deploy via ImagePolicy." >> $GITHUB_STEP_SUMMARY
```

---

### Phase 3: Bootstrap Module Modifications

#### 3.1 Add Source Type Variable

**File:** `infrastructure/modules/bootstrap/variables.tf` (add)

```hcl
variable "source_type" {
  description = "Flux sync source type: 'git' for GitRepository, 'oci' for OCIRepository"
  type        = string
  default     = "git"

  validation {
    condition     = contains(["git", "oci"], var.source_type)
    error_message = "source_type must be 'git' or 'oci'"
  }
}

variable "oci_registry" {
  description = "OCI registry URL (required when source_type = 'oci')"
  type        = string
  default     = ""
}

variable "oci_artifact_repo" {
  description = "OCI artifact repository path (required when source_type = 'oci')"
  type        = string
  default     = ""
}

variable "oci_tag_pattern" {
  description = "OCI tag pattern for ImagePolicy (e.g., 'integration-*' or 'validated-*')"
  type        = string
  default     = ""
}
```

#### 3.2 Create OCI Instance Template

**File:** `infrastructure/modules/bootstrap/resources/instance-oci.yaml.tftpl`

```yaml
instance:
  components:
    - source-controller
    - kustomize-controller
    - helm-controller
    - notification-controller
    - image-reflector-controller
    - image-automation-controller
  distribution:
    version: ${flux_version}
  cluster:
    size: small
  sync:
    kind: OCIRepository
    url: oci://${oci_registry}/${oci_artifact_repo}
    path: clusters/${cluster_name}
    ref: ${oci_tag_pattern}
    provider: generic
healthcheck:
  enabled: true
```

#### 3.3 Update flux.tf for Conditional Source

**File:** `infrastructure/modules/bootstrap/flux.tf` (modify helm_release.flux_instance)

```hcl
resource "helm_release" "flux_instance" {
  depends_on = [helm_release.flux_operator]

  name       = "flux"
  namespace  = "flux-system"
  repository = "oci://ghcr.io/controlplaneio-fluxcd/charts"
  chart      = "flux-instance"
  wait       = true
  timeout    = 300

  values = [
    var.source_type == "git" ? templatefile("${path.module}/resources/instance.yaml.tftpl", {
      cluster_name           = var.cluster_name
      github_org             = var.github.org
      github_repository      = var.github.repository
      github_repository_path = var.github.repository_path
      flux_version           = var.flux_version
    }) : templatefile("${path.module}/resources/instance-oci.yaml.tftpl", {
      cluster_name      = var.cluster_name
      oci_registry      = var.oci_registry
      oci_artifact_repo = var.oci_artifact_repo
      oci_tag_pattern   = var.oci_tag_pattern
      flux_version      = var.flux_version
    })
  ]
}
```

#### 3.4 Add ImagePolicy Resources for OCI Clusters

**File:** `infrastructure/modules/bootstrap/image-automation.tf` (new)

```hcl
# Image automation resources for OCI-based clusters
# Only created when source_type = "oci"

resource "kubernetes_manifest" "image_repository" {
  count = var.source_type == "oci" ? 1 : 0

  depends_on = [helm_release.flux_instance]

  manifest = {
    apiVersion = "image.toolkit.fluxcd.io/v1beta2"
    kind       = "ImageRepository"
    metadata = {
      name      = "platform"
      namespace = "flux-system"
    }
    spec = {
      image    = "${var.oci_registry}/${var.oci_artifact_repo}"
      interval = "1m"
      provider = "generic"
    }
  }
}

resource "kubernetes_manifest" "image_policy" {
  count = var.source_type == "oci" ? 1 : 0

  depends_on = [kubernetes_manifest.image_repository]

  manifest = {
    apiVersion = "image.toolkit.fluxcd.io/v1beta2"
    kind       = "ImagePolicy"
    metadata = {
      name      = "platform"
      namespace = "flux-system"
    }
    spec = {
      imageRepositoryRef = {
        name = "platform"
      }
      filterTags = {
        # Extract SHA from tag pattern (e.g., "integration-abc1234" -> "abc1234")
        pattern = "^${replace(var.oci_tag_pattern, "*", "(?P<sha>[a-f0-9]+)")}$"
        extract = "$sha"
      }
      policy = {
        alphabetical = {
          order = "desc"
        }
      }
    }
  }
}
```

#### 3.5 Update Units to Pass Source Type

**File:** `infrastructure/units/bootstrap/terragrunt.hcl` (modify inputs)

```hcl
inputs = {
  # ... existing inputs ...

  # Source configuration - determined by cluster name
  source_type       = local.cluster_name == "dev" ? "git" : "oci"
  oci_registry      = local.cluster_name != "dev" ? "ghcr.io" : ""
  oci_artifact_repo = local.cluster_name != "dev" ? "${local.github_org}/${local.github_repository}/platform" : ""
  oci_tag_pattern   = local.cluster_name == "integration" ? "integration-*" : (local.cluster_name == "live" ? "validated-*" : "")
}
```

---

### Phase 4: Flagger Validation

#### 4.1 Add Flagger to Helm Charts

**File:** `kubernetes/platform/helm-charts.yaml` (add to inputs)

```yaml
- name: flagger
  namespace: flux-system
  chart:
    name: flagger
    version: "1.37.0"
    repository: https://flagger.app
  depends_on:
    - prometheus
```

#### 4.2 Create Flagger Values

**File:** `kubernetes/platform/charts/flagger.yaml`

```yaml
prometheus:
  install: false
meshProvider: ""
metricsServer: http://prometheus.monitoring:9090
```

#### 4.3 Create Validation Gate Resources

**File:** `kubernetes/platform/config/flagger/kustomization.yaml`

```yaml
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization
namespace: flux-system
resources:
  - metric-templates.yaml
  - alert-provider.yaml
  - canary.yaml
```

**File:** `kubernetes/platform/config/flagger/metric-templates.yaml`

```yaml
apiVersion: flagger.app/v1beta1
kind: MetricTemplate
metadata:
  name: flux-reconciliation-health
  namespace: flux-system
spec:
  provider:
    type: prometheus
    address: http://prometheus.monitoring:9090
  query: |
    (
      sum(gotk_reconcile_condition{status="True",type="Ready",exported_namespace=~".*"})
      /
      sum(gotk_reconcile_condition{type="Ready",exported_namespace=~".*"})
    ) * 100
---
apiVersion: flagger.app/v1beta1
kind: MetricTemplate
metadata:
  name: pod-health
  namespace: flux-system
spec:
  provider:
    type: prometheus
    address: http://prometheus.monitoring:9090
  query: |
    (
      sum(kube_pod_status_phase{phase="Running"})
      /
      sum(kube_pod_status_phase{phase=~"Running|Pending|Failed"})
    ) * 100
```

**File:** `kubernetes/platform/config/flagger/alert-provider.yaml`

```yaml
apiVersion: flagger.app/v1beta1
kind: AlertProvider
metadata:
  name: github-dispatch
  namespace: flux-system
spec:
  type: webhook
  # Webhook URL configured via secret
  secretRef:
    name: flagger-github-webhook
```

**File:** `kubernetes/platform/config/flagger/canary.yaml`

```yaml
# Note: Flagger Canary for platform validation
# This monitors Flux reconciliation health, not a traditional deployment canary
apiVersion: flagger.app/v1beta1
kind: Canary
metadata:
  name: platform-validation-gate
  namespace: flux-system
  annotations:
    description: "Validates platform health before promotion to live"
spec:
  # We're not doing traditional canary - this is a validation gate
  # Target a dummy deployment or use Flagger's webhook-only mode
  provider: kubernetes

  # Minimal target (Flagger requires one)
  targetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: source-controller  # Flux component, always present

  # Disable actual canary behavior - we only want the analysis webhooks
  skipAnalysis: false

  analysis:
    # Run validation for 5 minutes (10 iterations * 30s)
    interval: 30s
    iterations: 10
    threshold: 2  # Allow 2 failures before marking as failed

    metrics:
      - name: flux-reconciliation-health
        templateRef:
          name: flux-reconciliation-health
        thresholdRange:
          min: 95  # 95% of Flux resources must be Ready

      - name: pod-health
        templateRef:
          name: pod-health
        thresholdRange:
          min: 90  # 90% of pods must be Running

    webhooks:
      # Custom smoke tests
      - name: smoke-tests
        type: pre-rollout
        url: http://flagger-loadtester.flux-system/
        timeout: 2m
        metadata:
          type: bash
          cmd: |
            # Verify critical services respond
            kubectl get --raw /healthz && \
            kubectl get pods -A --field-selector=status.phase!=Running,status.phase!=Succeeded | grep -q "No resources" || \
            [ $(kubectl get pods -A --field-selector=status.phase!=Running,status.phase!=Succeeded --no-headers | wc -l) -lt 5 ]

      # Trigger validation success webhook
      - name: notify-validation-success
        type: event
        url: http://github-webhook-relay.flux-system/dispatch
        metadata:
          event_type: artifact-validated
```

#### 4.4 Add Flagger LoadTester

**File:** `kubernetes/platform/helm-charts.yaml` (add to inputs)

```yaml
- name: flagger-loadtester
  namespace: flux-system
  chart:
    name: loadtester
    version: "0.31.0"
    repository: https://flagger.app
```

---

### Phase 5: GitHub Webhook Relay

For Flagger to trigger GitHub repository_dispatch, we need a relay service that holds the GitHub token.

#### 5.1 Create Webhook Relay Deployment

**File:** `kubernetes/platform/config/github-webhook-relay/kustomization.yaml`

```yaml
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization
namespace: flux-system
resources:
  - deployment.yaml
  - service.yaml
  - external-secret.yaml
```

**File:** `kubernetes/platform/config/github-webhook-relay/deployment.yaml`

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: github-webhook-relay
  namespace: flux-system
spec:
  replicas: 1
  selector:
    matchLabels:
      app: github-webhook-relay
  template:
    metadata:
      labels:
        app: github-webhook-relay
    spec:
      containers:
        - name: relay
          image: ghcr.io/fluxcd/notification-controller:v1.3.0
          args:
            - --health-addr=:9440
            - --events-addr=:9090
          ports:
            - containerPort: 9090
              name: http
            - containerPort: 9440
              name: health
          env:
            - name: GITHUB_TOKEN
              valueFrom:
                secretKeyRef:
                  name: github-webhook-token
                  key: token
          livenessProbe:
            httpGet:
              path: /healthz
              port: health
          readinessProbe:
            httpGet:
              path: /readyz
              port: health
```

**File:** `kubernetes/platform/config/github-webhook-relay/service.yaml`

```yaml
apiVersion: v1
kind: Service
metadata:
  name: github-webhook-relay
  namespace: flux-system
spec:
  selector:
    app: github-webhook-relay
  ports:
    - port: 80
      targetPort: 9090
```

**File:** `kubernetes/platform/config/github-webhook-relay/external-secret.yaml`

```yaml
apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name: github-webhook-token
  namespace: flux-system
spec:
  refreshInterval: 1h
  secretStoreRef:
    name: aws-parameter-store
    kind: ClusterSecretStore
  target:
    name: github-webhook-token
  data:
    - secretKey: token
      remoteRef:
        key: /homelab/github/webhook-token
```

---

### Phase 6: Documentation Updates

#### 6.1 Update CLAUDE.md

Remove all references to "soak period" and update the Environment Promotion Pipeline section:

```markdown
## Environment Promotion Pipeline

The `main` branch represents the desired state for production. Merging to `main` triggers artifact-based promotion:

```
PR merged to main
       ↓
  GHA builds OCI artifact
  (packages kubernetes/)
       ↓
  integration cluster
  (auto-deploys via ImagePolicy)
       ↓
  Flagger validation
  (Flux health + smoke tests)
       ↓
  GHA tags artifact as validated
       ↓
  live cluster
  (auto-deploys via ImagePolicy)
```

1. **Artifact build**: GHA packages `kubernetes/` directory as OCI artifact
2. **Integration deployment**: ImagePolicy auto-deploys `integration-*` tagged artifacts
3. **Validation**: Flagger runs health checks and smoke tests
4. **Promotion**: On validation success, artifact is re-tagged as `validated-*`
5. **Live deployment**: ImagePolicy auto-deploys `validated-*` tagged artifacts
```

#### 6.2 Archive Old Plan

Move `docs/plans/renovate-flux-promotion.md` to `docs/plans/.archive/` with a note that it's superseded by OCI artifact promotion.

---

## Rollback Procedures

### Immediate Rollback (Live Cluster)

```bash
# Find previous validated artifact
flux get artifact oci://ghcr.io/<org>/homelab/platform --all-tags | grep validated

# Re-tag previous version as latest
PREVIOUS_SHA="abc1234"  # Replace with actual SHA
flux tag artifact \
  oci://ghcr.io/<org>/homelab/platform:validated-${PREVIOUS_SHA} \
  --tag validated-rollback

# ImagePolicy will pick up the new tag and update live cluster
```

### Manual Override (Emergency)

```bash
# Directly patch OCIRepository to pin specific version
kubectl -n flux-system patch ocirepository platform \
  --type merge \
  -p '{"spec":{"ref":{"tag":"validated-<known-good-sha>"}}}'

# Suspend ImageUpdateAutomation to prevent automatic updates
flux suspend image update platform -n flux-system
```

### Recovery

```bash
# Resume normal operation
flux resume image update platform -n flux-system

# Remove rollback tag
# (Next successful validation will create new validated-* tag)
```

---

## Verification Checklist

### Phase 1: Build Pipeline
- [ ] GHA workflow triggers on kubernetes/ changes
- [ ] Artifact pushed to GHCR with correct tags
- [ ] Manual workflow_dispatch works

### Phase 2: Integration Deployment
- [ ] Terragrunt generates OCIRepository config for integration
- [ ] Integration cluster syncs from OCI artifact
- [ ] ImagePolicy detects new integration-* tags
- [ ] ImageUpdateAutomation creates commits

### Phase 3: Validation
- [ ] Flagger deployed and healthy
- [ ] MetricTemplates query Prometheus successfully
- [ ] Smoke tests execute via loadtester
- [ ] Webhook relay dispatches to GitHub

### Phase 4: Live Promotion
- [ ] Validation success triggers tag-validated workflow
- [ ] Live cluster ImagePolicy picks up validated-* tags
- [ ] End-to-end: code change → integration → validation → live

### Phase 5: Rollback
- [ ] Manual rollback procedure works
- [ ] Emergency override procedure works
- [ ] Recovery from rollback restores normal operation

---

## Migration Path

1. **Parallel operation**: Keep GitRepository working while testing OCI
2. **Integration first**: Migrate integration cluster to OCI, keep live on git
3. **Validate flow**: Ensure artifact build → integration deploy → validation works
4. **Live migration**: After confidence in integration, migrate live to OCI
5. **Cleanup**: Remove GitRepository resources from integration/live
